/**
 * Image Optimization Utilities
 * Handles image loading, optimization, and performance enhancements
 */

// Image format support detection
export const supportsWebP = () => {
  if (typeof window === 'undefined') return false;
  
  const canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  
  return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
};

export const supportsAVIF = () => {
  if (typeof window === 'undefined') return false;
  
  const canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 1;
  
  return canvas.toDataURL('image/avif').indexOf('data:image/avif') === 0;
};

// Generate responsive image sources
export const generateResponsiveSources = (baseSrc, breakpoints = [640, 768, 1024, 1280, 1536]) => {
  const sources = [];
  
  breakpoints.forEach(width => {
    // In a real implementation, these would be generated by a build process
    // or served by an image optimization service
    sources.push({
      width,
      src: baseSrc, // For now, using original src
      webp: baseSrc.replace(/\.(jpg|jpeg|png)$/i, '.webp'),
      avif: baseSrc.replace(/\.(jpg|jpeg|png)$/i, '.avif')
    });
  });
  
  return sources;
};

// Create srcSet string for responsive images
export const createSrcSet = (sources, format = 'original') => {
  return sources
    .map(source => {
      const src = format === 'webp' ? source.webp : 
                  format === 'avif' ? source.avif : source.src;
      return `${src} ${source.width}w`;
    })
    .join(', ');
};

// Generate sizes attribute based on layout
export const generateSizes = (layout = 'responsive') => {
  const sizeMap = {
    responsive: '(min-width: 1280px) 50vw, (min-width: 1024px) 60vw, (min-width: 768px) 80vw, 100vw',
    hero: '(min-width: 1024px) 40vw, (min-width: 768px) 60vw, 90vw',
    thumbnail: '(min-width: 1024px) 200px, (min-width: 768px) 150px, 100px',
    fullWidth: '100vw'
  };
  
  return sizeMap[layout] || sizeMap.responsive;
};

// Preload critical images
export const preloadImage = (src, priority = false) => {
  if (typeof window === 'undefined') return Promise.resolve();
  
  return new Promise((resolve, reject) => {
    const img = new Image();
    
    img.onload = () => resolve(img);
    img.onerror = reject;
    
    // Set priority loading attributes
    if (priority) {
      img.loading = 'eager';
      img.fetchPriority = 'high';
    }
    
    img.src = src;
  });
};

// Lazy loading with intersection observer
export const createLazyLoader = (options = {}) => {
  const defaultOptions = {
    rootMargin: '50px',
    threshold: 0.1,
    ...options
  };
  
  if (typeof window === 'undefined' || !('IntersectionObserver' in window)) {
    return null;
  }
  
  return new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        const src = img.dataset.src;
        
        if (src) {
          img.src = src;
          img.removeAttribute('data-src');
        }
        
        // Trigger custom load event
        img.dispatchEvent(new CustomEvent('lazyload'));
      }
    });
  }, defaultOptions);
};

// Image error handling and fallbacks
export const handleImageError = (img, fallbackSrc = null) => {
  if (img.dataset.retryCount) {
    const retryCount = parseInt(img.dataset.retryCount);
    if (retryCount >= 3) {
      // Max retries reached, show fallback
      if (fallbackSrc) {
        img.src = fallbackSrc;
      } else {
        img.style.display = 'none';
      }
      return;
    }
    img.dataset.retryCount = (retryCount + 1).toString();
  } else {
    img.dataset.retryCount = '1';
  }
  
  // Retry loading after a delay
  setTimeout(() => {
    const originalSrc = img.dataset.originalSrc || img.src;
    img.src = originalSrc + '?retry=' + img.dataset.retryCount;
  }, 1000 * parseInt(img.dataset.retryCount));
};

// Progressive image loading with blur effect
export const createProgressiveLoader = (lowQualitySrc, highQualitySrc) => {
  return new Promise((resolve) => {
    const lowQualityImg = new Image();
    const highQualityImg = new Image();
    
    lowQualityImg.onload = () => {
      // Show low quality image immediately
      resolve({
        type: 'low-quality',
        src: lowQualitySrc,
        img: lowQualityImg
      });
      
      // Start loading high quality image
      highQualityImg.onload = () => {
        resolve({
          type: 'high-quality',
          src: highQualitySrc,
          img: highQualityImg
        });
      };
      
      highQualityImg.src = highQualitySrc;
    };
    
    lowQualityImg.src = lowQualitySrc;
  });
};

// Calculate optimal image dimensions
export const calculateOptimalDimensions = (containerWidth, containerHeight, imageAspectRatio) => {
  const containerAspectRatio = containerWidth / containerHeight;
  
  if (imageAspectRatio > containerAspectRatio) {
    // Image is wider than container
    return {
      width: containerWidth,
      height: containerWidth / imageAspectRatio
    };
  } else {
    // Image is taller than container
    return {
      width: containerHeight * imageAspectRatio,
      height: containerHeight
    };
  }
};

// Performance monitoring for images
export const monitorImagePerformance = (img, startTime = performance.now()) => {
  const endTime = performance.now();
  const loadTime = endTime - startTime;
  
  // Log performance metrics
  if (window.gtag) {
    window.gtag('event', 'image_load_time', {
      event_category: 'Performance',
      event_label: img.src,
      value: Math.round(loadTime)
    });
  }
  
  // Report to performance API if available
  if ('PerformanceObserver' in window) {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.name === img.src) {
          console.log(`Image ${img.src} loaded in ${entry.duration}ms`);
        }
      });
    });
    
    observer.observe({ entryTypes: ['resource'] });
  }
  
  return loadTime;
};

// Blood donation specific image configurations
export const bloodDonationImageConfig = {
  primary: {
    src: '/Blood Donation 1.jpg',
    alt: 'Blood donation process showing donor privacy protection and safe donation environment',
    aspectRatio: '4/3',
    priority: true,
    sizes: '(min-width: 1024px) 40vw, (min-width: 768px) 60vw, 90vw'
  },
  secondary: {
    src: '/Blood Donation 2.jpg',
    alt: 'Community blood donation highlighting social impact and life-saving mission',
    aspectRatio: '3/4',
    priority: false,
    sizes: '(min-width: 1024px) 30vw, (min-width: 768px) 50vw, 80vw'
  }
};

// Export all utilities
export default {
  supportsWebP,
  supportsAVIF,
  generateResponsiveSources,
  createSrcSet,
  generateSizes,
  preloadImage,
  createLazyLoader,
  handleImageError,
  createProgressiveLoader,
  calculateOptimalDimensions,
  monitorImagePerformance,
  bloodDonationImageConfig
};